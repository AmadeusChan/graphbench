/*
This class is adjusted according to the output generated by Green-Marl compiler
*/
import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.lang.Math;
import java.util.Random;
import java.util.ArrayList;
import java.util.Arrays;
import org.apache.giraph.aggregators.*;
import org.apache.giraph.graph.*;
import org.apache.giraph.master.*;
import org.apache.hadoop.io.*;
import org.apache.log4j.Logger;
import org.apache.giraph.io.formats.BCMessage;
import org.apache.giraph.io.formats.BCNode;

public class BCComputation extends
		BasicComputation<LongWritable, BCNode, FloatWritable, BCMessage> {

	private static final Logger LOG = Logger.getLogger(BCComputation.class);

	// Keys for shared_variables
	private static final String KEY_s = "s";
	private static final String KEY_bfs_finished = "bfs_finished";
	private static final String KEY_curr_level = "curr_level";

	// master states to share with vertices
	private static final int INITIALIZE1 = 0;
	private static final int INITIALIZE2 = 1;
	private static final int OUTERLOOP = 2;
	private static final int SIGMAANDLEVEL = 3;
	private static final int BFS = 4;
	private static final int SENDEMPTYMESSAGE = 5;
	private static final int BFSDONE1 = 6;
	private static final int SETLEVELORPASSSIGMA = 7;
	private static final int BFSDONE2 = 8;
	private static final int PASSSIGMA = 9;
	private static final int REVERSEMESSAGE = 10;
	private static final int CALCULATEBC = 11;
	private static final int CONTINUELOOP = 12;

	// create a master to control other vertices
	public static class Master extends MasterCompute {
		private int master_state = 0;
		private int master_state_nxt = 0;
		private boolean master_should_start_workers = false;
		private boolean master_should_finish = false;

		// number of total outer loops
		private int K;
		// current index in the loop
		private int k;
		// the root for the current BFS
		private long s;
		private boolean bfs_finished;
		private int curr_level;

		public void initialize() throws InstantiationException,
				IllegalAccessException {
			registerPersistentAggregator("current_state",
					IntOverwriteAggregator.class);
			registerPersistentAggregator(KEY_s, LongOverwriteAggregator.class);
			registerPersistentAggregator(KEY_bfs_finished,
					BooleanAndAggregator.class);
			registerPersistentAggregator(KEY_curr_level,
					IntOverwriteAggregator.class);
		}

		public void compute() {
			if (getSuperstep() == 0) {
				return;
			}
			master_state_machine();
			if (master_should_finish) {
				haltComputation();
			}
		}

		// ----------------------------------------------------------
		// Master's State-machine
		// ----------------------------------------------------------
		private void master_state_machine() {
			master_should_start_workers = false;
			master_should_finish = false;
			do {
				master_state = master_state_nxt;
				switch (master_state) {
				case INITIALIZE1:
					// everyone sends message to the neighbors and set BC = 0, k
					// = 0;
					master_initialize1();
					break;
				case INITIALIZE2:
					// everyone receives message from the neighbors and save it
					master_initialize2();
					break;
				case OUTERLOOP:
					// if has gone through K times, exit
					// otherwise, pick a random vertex to be the root
					master_outerLoop();
					break;
				case SIGMAANDLEVEL:
					// set the master node to have level -1 and ask the
					// vertex to set up the initial sigma and the level
					master_sigmaAndLevel();
					break;
				case BFS:
					// increment the level and continue to do bfs
					// or bfs has done, either decrement the level or start a
					// totally new loop
					master_bfs();
					break;
				case SENDEMPTYMESSAGE:
					// if I am the nodes on the current level, send an empty
					// messages to the neighbors
					master_sendEmptyMessage();
					break;
				case BFSDONE1:
					// check if all the bfs have been done
					master_bfsDone1();
					break;
				case SETLEVELORPASSSIGMA:
					// Nodes receive messages and if have not been visited
					// before, set my level
					// else if I am on the shortest path, pass on the sigma
					master_setLevelOrPassSigma();
					break;
				case BFSDONE2:
					// check if all the bfs have been done
					master_bfsDone2();
					break;
				case PASSSIGMA:
					// pass on the sigma value to the next level
					master_passSigma();
					break;
				case REVERSEMESSAGE:
					// send the sigma and delta to the reverse nodes
					master_reverseMessage();
					break;
				case CALCULATEBC:
					// calculate the BC
					master_calculateBC();
					break;
				case CONTINUELOOP:
					// check if all the BC have been computed, then k++
					// else keep computing BC
					master_continueLoop();
				}
			} while (!master_should_start_workers && !master_should_finish);
		}

		/**
		 * prepare the initial condition
		 */
		private void master_initialize1() {
			LOG.info("Running master_state initialize1");
			setAggregatedValue("current_state", new IntWritable(master_state));
			k = 0;
			master_state_nxt = INITIALIZE2;
			master_should_start_workers = true;
		}

		/**
		 * create the reverse nodes
		 */
		private void master_initialize2() {
			LOG.info("Running master_state initialize2");
			setAggregatedValue("current_state", new IntWritable(master_state));
			K = (int) getTotalNumVertices();
			master_state_nxt = OUTERLOOP;
			master_should_start_workers = true;
		}

		/**
		 * if has gone through all the K loops
		 */
		private void master_outerLoop() {
			LOG.info("Running master_state outerLoop");
			if (k < K) {
				// s = gmGetRandomLongInRange(getTotalNumVertices() - 1);
				s = k;
				master_state_nxt = SIGMAANDLEVEL;
			} else {
				master_should_finish = true;
			}
		}

		/**
		 * register the root in the log file and keep running
		 */
		private void master_sigmaAndLevel() {
			LOG.info("Running master_state sigmaAndLevel");
			setAggregatedValue(KEY_s, new LongWritable(s));
			setAggregatedValue("current_state", new IntWritable(master_state));
			// the master level is -1 and ask the vertex to do the bfs
			curr_level = -1;
			bfs_finished = false;
			master_state_nxt = BFS;
			master_should_start_workers = true;
		}

		/**
		 * check if bfs is finished or not
		 */
		private void master_bfs() {
			LOG.info("Running master_state bfs");
			if (!bfs_finished) {
				bfs_finished = true;
				curr_level = curr_level + 1;
				master_state_nxt = SENDEMPTYMESSAGE;
			} else {
				master_state_nxt = CONTINUELOOP;
			}
		}

		/**
		 * ask the vertex to update the level
		 */
		private void master_sendEmptyMessage() {
			LOG.info("Running master_state sendEmptyMessage");
			setAggregatedValue(KEY_bfs_finished, new BooleanWritable(true));
			setAggregatedValue(KEY_curr_level, new IntWritable(curr_level));
			setAggregatedValue("current_state", new IntWritable(master_state));

			master_state_nxt = BFSDONE1;
			master_should_start_workers = true;
		}

		private void master_bfsDone1() {
			LOG.info("Running _master_state bfsDone1");
			bfs_finished = bfs_finished
					&& this.<BooleanWritable> getAggregatedValue(
							KEY_bfs_finished).get();

			master_state_nxt = SETLEVELORPASSSIGMA;
		}

		private void master_setLevelOrPassSigma() {
			LOG.info("Running master_state setLevelOrPassSigma");
			setAggregatedValue(KEY_bfs_finished, new BooleanWritable(true));
			setAggregatedValue(KEY_curr_level, new IntWritable(curr_level));
			setAggregatedValue("current_state", new IntWritable(master_state));

			master_state_nxt = BFSDONE2;
			master_should_start_workers = true;
		}

		private void master_bfsDone2() {
			LOG.info("Running master_state bfsDone2");
			bfs_finished = bfs_finished
					&& this.<BooleanWritable> getAggregatedValue(
							KEY_bfs_finished).get();

			master_state_nxt = PASSSIGMA;
		}

		private void master_passSigma() {
			LOG.info("Running master_state passSigma");
			setAggregatedValue(KEY_curr_level, new IntWritable(curr_level));
			setAggregatedValue("current_state", new IntWritable(master_state));

			master_state_nxt = BFS;
			master_should_start_workers = true;
		}

		private void master_reverseMessage() {
			LOG.info("Running master_state reverseMessage");
			setAggregatedValue(KEY_curr_level, new IntWritable(curr_level));
			setAggregatedValue("current_state", new IntWritable(master_state));

			master_state_nxt = CALCULATEBC;
			master_should_start_workers = true;
		}

		private void master_calculateBC() {
			LOG.info("Running master_state claculateBC");
			setAggregatedValue(KEY_curr_level, new IntWritable(curr_level));
			setAggregatedValue("current_state", new IntWritable(master_state));

			master_should_start_workers = true;
			master_state_nxt = CONTINUELOOP;
		}

		private void master_continueLoop() {
			LOG.info("Running master_state continueLoop");
			curr_level = curr_level - 1;
			if (curr_level >= 0) {
				master_state_nxt = REVERSEMESSAGE;
			} else {
				k = k + 1;
				master_state_nxt = OUTERLOOP;
			}
		}

		@Override
		public void write(DataOutput out) throws IOException {
			out.writeInt(master_state);
			out.writeInt(master_state_nxt);
			out.writeBoolean(master_should_start_workers);
			out.writeBoolean(master_should_finish);
			out.writeInt(K);
			out.writeInt(k);
			out.writeLong(s);
			out.writeBoolean(bfs_finished);
			out.writeInt(curr_level);
		}

		@Override
		public void readFields(DataInput in) throws IOException {
			master_state = in.readInt();
			master_state_nxt = in.readInt();
			master_should_start_workers = in.readBoolean();
			master_should_finish = in.readBoolean();
			K = in.readInt();
			k = in.readInt();
			s = in.readLong();
			bfs_finished = in.readBoolean();
			curr_level = in.readInt();
		}
	} // end of mastercompute

	@Override
	public void compute(Vertex<LongWritable, BCNode, FloatWritable> vertex,
			Iterable<BCMessage> msgs) throws IOException {
		int state_vertex = this.<IntWritable> getAggregatedValue(
				"current_state").get();
		switch (state_vertex) {
		case INITIALIZE1:
			vertex_initialize1(msgs, vertex);
			break;
		case INITIALIZE2:
			vertex_initialize2(msgs, vertex);
			break;
		case SIGMAANDLEVEL:
			vertex_sigmaAndLevel(msgs, vertex);
			break;
		case SENDEMPTYMESSAGE:
			vertex_sendEmptyMessage(msgs, vertex);
			break;
		case SETLEVELORPASSSIGMA:
			vertex_setLevelOrPassSigma(msgs, vertex);
			break;
		case PASSSIGMA:
			vertex_passSigma(msgs, vertex);
			break;
		case REVERSEMESSAGE:
			vertex_reverseMessage(msgs, vertex);
			break;
		case CALCULATEBC:
			vertex_calculateBC(msgs, vertex);
			break;
		}
	}

	// every vertex send itself to the neighbor, imaging it is creating the
	// graph
	private void vertex_initialize1(Iterable<BCMessage> msgs,
			Vertex<LongWritable, BCNode, FloatWritable> vertex) {
		BCNode _this = vertex.getValue();
		_this.BC = (float) 0;
		long remoteNodeId = vertex.getId().get();
		if (vertex.getNumEdges() > 0) {
			// type of the message is long
			BCMessage msg = new BCMessage((byte) 0);
			msg.l0 = remoteNodeId;
			sendMessageToAllEdges(vertex, msg);
		}
	}

	// count how many messages this node received and save all the id of the
	// senders
	private void vertex_initialize2(Iterable<BCMessage> msgs,
			Vertex<LongWritable, BCNode, FloatWritable> vertex) {
		BCNode _this = vertex.getValue();
		for (BCMessage _msg : msgs) {
			long _remoteNodeId = _msg.l0;
			_this.revNodeId.add(new LongWritable(_remoteNodeId));
		}
	}

	/**
	 * set the initial condition for the BFS
	 * 
	 * @param msgs
	 */
	private void vertex_sigmaAndLevel(Iterable<BCMessage> msgs,
			Vertex<LongWritable, BCNode, FloatWritable> vertex) {
		BCNode _this = vertex.getValue();
		long s = this.<LongWritable> getAggregatedValue(KEY_s).get();
		{
			// if I am the root, then my sigma is 1, otherwise is 0
			_this.sigma = (float) 0;
			if (vertex.getId().get() == s)
				_this.sigma = (float) 1;
		}

		{ // if I am the root, then my level is 0
			_this.level = (vertex.getId().get() == s) ? 0 : Integer.MAX_VALUE;
		}
	}

	private void vertex_sendEmptyMessage(Iterable<BCMessage> msgs,
			Vertex<LongWritable, BCNode, FloatWritable> vertex) {
		BCNode _this = vertex.getValue();
		// get the updated level
		int curr_level = this.<IntWritable> getAggregatedValue(KEY_curr_level)
				.get();
		{
			// if I am the level of nodes
			if (_this.level == curr_level) {
				if (vertex.getNumEdges() > 0) {
					// this message does not contain anything
					BCMessage msg = new BCMessage((byte) 1);
					sendMessageToAllEdges(vertex, msg);
				}
			}
		}
	}

	private void vertex_setLevelOrPassSigma(Iterable<BCMessage> msgs,
			Vertex<LongWritable, BCNode, FloatWritable> vertex) {
		BCNode _this = vertex.getValue();
		int curr_level = this.<IntWritable> getAggregatedValue(KEY_curr_level)
				.get();
		// Begin msg receive
		for (BCMessage msg : msgs) {
			// has not been visited before
			if (_this.level == Integer.MAX_VALUE) {
				_this.level = curr_level + 1;
				// means that bfs has not finished yet
				aggregate(KEY_bfs_finished, new BooleanWritable(false));
			}
		}
		{ // this nodes is on the shortest path
			if (_this.level == curr_level) {
				if (vertex.getNumEdges() > 0) {
					// the message contains a float
					BCMessage msg = new BCMessage((byte) 2);
					msg.f0 = _this.sigma;
					sendMessageToAllEdges(vertex, msg);
				}
			}
		}
	}

	private void vertex_passSigma(Iterable<BCMessage> msgs,
			Vertex<LongWritable, BCNode, FloatWritable> vertex) {
		BCNode _this = vertex.getValue();
		int curr_level = this.<IntWritable> getAggregatedValue(KEY_curr_level)
				.get();

		// pass on the sigma value to the next level
		for (BCMessage msg : msgs) {
			if (_this.level == curr_level + 1) {
				_this.sigma = _this.sigma + msg.f0;
			}
		}
	}

	private void vertex_reverseMessage(Iterable<BCMessage> msgs,
			Vertex<LongWritable, BCNode, FloatWritable> vertex) {
		BCNode _this = vertex.getValue();
		int curr_level = this.<IntWritable> getAggregatedValue(KEY_curr_level)
				.get();
		{
			if (_this.level == curr_level) {
				_this.__S3prop = ((float) (0.000000));
			}
		}
		{
			if (_this.level == curr_level + 1) {
				// if this has neighbor, send the sigma and delta to the rev
				// nodes
				if (_this.revNodeId.size() > 0) {
					BCMessage msg = new BCMessage((byte) 3);
					msg.f0 = _this.sigma;
					msg.f1 = (1 + _this.delta);
					for (LongWritable _v_node : _this.revNodeId) {
						sendMessage(_v_node, msg);
					}
				}
			}
		}
	}

	private void vertex_calculateBC(Iterable<BCMessage> msgs,
			Vertex<LongWritable, BCNode, FloatWritable> vertex) {
		BCNode _this = vertex.getValue();
		int curr_level = this.<IntWritable> getAggregatedValue(KEY_curr_level)
				.get();

		for (BCMessage msg : msgs) {
			if (_this.level == curr_level)
				_this.__S3prop = _this.__S3prop
						+ (_this.sigma / msg.f0 * msg.f1);
		}
		{
			if (_this.level == curr_level) {
				_this.delta = _this.__S3prop;
				_this.BC = _this.BC + _this.delta;
			}
		}
	}

	/**
	 * create a random for the root
	 * 
	 * @param gsize
	 * @return
	 */
	/*
	 * public static long gmGetRandomLongInRange(long gsize) { Random rand = new
	 * Random(); return (long) rand.nextInt((int) gsize); }
	 */
}
